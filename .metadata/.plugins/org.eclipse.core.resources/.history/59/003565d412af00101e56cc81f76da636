package edu.infosys.lostAndFoundApplication.service;

import edu.infosys.lostAndFoundApplication.bean.FoundItem;
import edu.infosys.lostAndFoundApplication.bean.LostItem;
import edu.infosys.lostAndFoundApplication.dao.FoundItemRepository;
import edu.infosys.lostAndFoundApplication.dao.FuzzyLogicRepository;
import edu.infosys.lostAndFoundApplication.dao.LostItemRepository;
import org.apache.commons.text.similarity.JaroWinklerSimilarity;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

import java.util.*;
import java.util.stream.Collectors;

@Service
public class FuzzyLogic {

    @Autowired
    private LostItemRepository lostItemRepository;

    @Autowired
    private FoundItemRepository foundItemRepository;

    @Autowired
    private FuzzyLogicRepository fuzzyLogicRepository;

    private final JaroWinklerSimilarity jaro = new JaroWinklerSimilarity();

    private static final double ITEM_NAME_WEIGHT = 0.50;
    private static final double BRAND_WEIGHT = 0.25;
    private static final double COLOR_WEIGHT = 0.15;
    private static final double CATEGORY_WEIGHT = 0.10;

    private static final double MINIMUM_ITEM_NAME_SIMILARITY = 0.6;

    public List<FoundItem> findMatchingFoundItems(String lostItemId, double threshold) {
        Optional<LostItem> lostItemOptional = lostItemRepository.findById(lostItemId);

        if (lostItemOptional.isEmpty()) {
            return Collections.emptyList();
        }
        LostItem lostItem = lostItemOptional.get();
        String usernameOfLoser = lostItem.getUsername();

        List<FoundItem> potentialMatches = fuzzyLogicRepository.findPotentialFoundMatches(usernameOfLoser, lostItem.getCategory());

        List<FoundItem> matches = new ArrayList<>();

        for (FoundItem foundItem : potentialMatches) {
            String lostItemName = normalize(lostItem.getItemName());
            String foundItemName = normalize(foundItem.getItemName());

            // Use enhanced similarity for item name
            double itemNameScore = calculateEnhancedSimilarity(lostItemName, foundItemName);

            if (itemNameScore < MINIMUM_ITEM_NAME_SIMILARITY) {
                continue;
            }

            String lostBrand = normalize(lostItem.getBrand());
            String foundBrand = normalize(foundItem.getBrand());
            String lostColor = normalize(lostItem.getColor());
            String foundColor = normalize(foundItem.getColor());
            String lostCategory = normalize(lostItem.getCategory());
            String foundCategory = normalize(foundItem.getCategory());

            // Use enhanced similarity for all fields
            double brandScore = calculateEnhancedSimilarity(lostBrand, foundBrand);
            double colorScore = calculateEnhancedSimilarity(lostColor, foundColor);
            double categoryScore = calculateEnhancedSimilarity(lostCategory, foundCategory);

            double averageScore = (itemNameScore * ITEM_NAME_WEIGHT) +
                    (brandScore * BRAND_WEIGHT) +
                    (colorScore * COLOR_WEIGHT) +
                    (categoryScore * CATEGORY_WEIGHT);

            if (averageScore >= threshold) {
                matches.add(foundItem);
            }
        }
        return matches;
    }

    public List<LostItem> findMatchingLostItems(String foundItemId, double threshold) {
        Optional<FoundItem> foundItemOptional = foundItemRepository.findById(foundItemId);

        if (foundItemOptional.isEmpty()) {
            return Collections.emptyList();
        }
        FoundItem foundItem = foundItemOptional.get();
        String usernameOfFinder = foundItem.getUsername();

        List<LostItem> potentialMatches = fuzzyLogicRepository.findPotentialLostMatches(usernameOfFinder, foundItem.getCategory());

        List<LostItem> matches = new ArrayList<>();

        for (LostItem lostItem : potentialMatches) {
            String foundItemName = normalize(foundItem.getItemName());
            String lostItemName = normalize(lostItem.getItemName());

            // Use enhanced similarity for item name
            double itemNameScore = calculateEnhancedSimilarity(foundItemName, lostItemName);

            if (itemNameScore < MINIMUM_ITEM_NAME_SIMILARITY) {
                continue;
            }

            String foundBrand = normalize(foundItem.getBrand());
            String lostBrand = normalize(lostItem.getBrand());
            String foundColor = normalize(foundItem.getColor());
            String lostColor = normalize(lostItem.getColor());
            String foundCategory = normalize(foundItem.getCategory());
            String lostCategory = normalize(lostItem.getCategory());

            // Use enhanced similarity for all fields
            double brandScore = calculateEnhancedSimilarity(foundBrand, lostBrand);
            double colorScore = calculateEnhancedSimilarity(foundColor, lostColor);
            double categoryScore = calculateEnhancedSimilarity(foundCategory, lostCategory);

            double averageScore = (itemNameScore * ITEM_NAME_WEIGHT) +
                    (brandScore * BRAND_WEIGHT) +
                    (colorScore * COLOR_WEIGHT) +
                    (categoryScore * CATEGORY_WEIGHT);

            if (averageScore >= threshold) {
                matches.add(lostItem);
            }
        }
        return matches;
    }

    public List<FoundItem> searchFoundItems(String query, String username, double threshold) {
        List<FoundItem> potential = fuzzyLogicRepository.findAllFoundExcludingUser(username);
        Map<FoundItem, Double> scored = new HashMap<>();

        String q = normalize(query);
        for (FoundItem f : potential) {
            // Use enhanced similarity for all fields in global search
            double itemNameScore = calculateEnhancedSimilarity(q, normalize(f.getItemName()));
            double brandScore = calculateEnhancedSimilarity(q, normalize(f.getBrand()));
            double colorScore = calculateEnhancedSimilarity(q, normalize(f.getColor()));
            double categoryScore = calculateEnhancedSimilarity(q, normalize(f.getCategory()));
            double locationScore = calculateEnhancedSimilarity(q, normalize(f.getLocation()));

            // Give item name score the highest priority
            double score = (itemNameScore * 0.5) + // Increased weight for item name
                    (brandScore * 0.15) +
                    (colorScore * 0.1) +
                    (categoryScore * 0.15) +
                    (locationScore * 0.1);

            // We also check if the item name score *itself* is above a certain threshold
            // to ensure "drive" matching "pen drive" gets a high chance.
            if (score >= threshold && (itemNameScore > 0.6 || score > (threshold * 1.2))) {
                scored.put(f, score);
            }
        }

        return scored.entrySet().stream()
                .sorted(Map.Entry.<FoundItem, Double>comparingByValue().reversed())
                .map(Map.Entry::getKey)
                .collect(Collectors.toList());
    }

    public List<LostItem> searchLostItems(String query, String username, double threshold) {
        List<LostItem> potential = fuzzyLogicRepository.findAllLostExcludingUser(username);
        Map<LostItem, Double> scored = new HashMap<>();

        String q = normalize(query);
        for (LostItem l : potential) {
            // Use enhanced similarity for all fields in global search
            double itemNameScore = calculateEnhancedSimilarity(q, normalize(l.getItemName()));
            double brandScore = calculateEnhancedSimilarity(q, normalize(l.getBrand()));
            double colorScore = calculateEnhancedSimilarity(q, normalize(l.getColor()));
            double categoryScore = calculateEnhancedSimilarity(q, normalize(l.getCategory()));
            double locationScore = calculateEnhancedSimilarity(q, normalize(l.getLocation()));

            // Give item name score the highest priority
            double score = (itemNameScore * 0.5) + // Increased weight for item name
                    (brandScore * 0.15) +
                    (colorScore * 0.1) +
                    (categoryScore * 0.15) +
                    (locationScore * 0.1);

            if (score >= threshold && (itemNameScore > 0.6 || score > (threshold * 1.2))) {
                scored.put(l, score);
            }
        }

        return scored.entrySet().stream()
                .sorted(Map.Entry.<LostItem, Double>comparingByValue().reversed())
                .map(Map.Entry::getKey)
                .collect(Collectors.toList());
    }

    private String normalize(String input) {
        return (input == null) ? "" : input.toLowerCase().trim();
    }

    /**
     * Calculates similarity by first checking for substring containment,
     * then falling back to Jaro-Winkler similarity for typo tolerance.
     *
     * @param s1 Normalized string 1
     * @param s2 Normalized string 2
     * @return A similarity score between 0.0 and 1.0
     */
    private double calculateEnhancedSimilarity(String s1, String s2) {
        if (s1.isEmpty() && s2.isEmpty()) {
            return 1.0; // Both are empty, perfect match
        }
        if (s1.isEmpty() || s2.isEmpty()) {
            return 0.0; // One is empty, no match
        }

        // 1. Substring Check (e.g., "drive" in "pen drive")
        if (s1.contains(s2) || s2.contains(s1)) {
            return 1.0; // Perfect match if one contains the other
        }

        // 2. Fallback to Jaro-Winkler for typo tolerance (e.g., "wallet" vs "walet")
        return jaro.apply(s1, s2);
    }
}